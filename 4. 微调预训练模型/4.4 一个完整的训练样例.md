# ä¸€ä¸ªå®Œæ•´çš„è®­ç»ƒæ ·ä¾‹

ç°åœ¨æˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•åœ¨ä¸ä½¿ç”¨ Trainer ç±»çš„æƒ…å†µä¸‹è·å¾—ä¸ä¸Šä¸€èŠ‚ç›¸åŒçš„ç»“æœã€‚ åŒæ ·ï¼Œæˆ‘ä»¬å‡è®¾æ‚¨å·²ç»å®Œæˆäº†ç¬¬ 3èŠ‚ä¸­çš„æ•°æ®å¤„ç†ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€çŸ­çš„æ‘˜è¦ï¼Œæ¶µç›–äº†æ‚¨éœ€è¦çš„æ‰€æœ‰å†…å®¹ï¼š 

```python
from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)

def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)

tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
```

# å‡†å¤‡æ•°æ®è®­ç»ƒ

åœ¨å®é™…ç¼–å†™æˆ‘ä»¬çš„è®­ç»ƒå¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€äº›å¯¹è±¡ã€‚ ç¬¬ä¸€ä¸ªæ˜¯æˆ‘ä»¬å°†ç”¨äºè¿­ä»£æ‰¹æ¬¡çš„æ•°æ®åŠ è½½å™¨ã€‚ ä½†æ˜¯åœ¨æˆ‘ä»¬å®šä¹‰è¿™äº›æ•°æ®åŠ è½½å™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æˆ‘ä»¬çš„ tokenized_datasets åº”ç”¨ä¸€äº›åå¤„ç†ï¼Œä»¥å…³æ³¨ Trainer è‡ªåŠ¨ä¸ºæˆ‘ä»¬åšçš„ä¸€äº›äº‹æƒ…ã€‚ å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦ï¼š 

- åˆ é™¤ä¸æ¨¡å‹ä¸ç›¸å…³çš„å€¼ç›¸å¯¹åº”çš„åˆ—ï¼ˆå¦‚å¥å­ 1 å’Œå¥å­ 2 åˆ—ï¼‰ã€‚ 
- å°†åˆ—æ ‡ç­¾é‡å‘½åä¸ºæ ‡ç­¾ï¼ˆå› ä¸ºæ¨¡å‹æœŸæœ›å‚æ•°è¢«å‘½åä¸ºæ ‡ç­¾ã€‚ 
- è®¾ç½®æ•°æ®é›†çš„æ ¼å¼ï¼Œä½¿å…¶è¿”å› PyTorch å¼ é‡è€Œä¸æ˜¯åˆ—è¡¨ã€‚ 

æˆ‘ä»¬çš„ tokenized_datasets å¯¹æ¯ä¸ªæ­¥éª¤éƒ½æœ‰ä¸€ä¸ªæ–¹æ³•ï¼š 

```python
tokenized_datasets = tokenized_datasets.remove_columns(
    ["sentence1", "sentence2", "idx"]
)
tokenized_datasets = tokenized_datasets.rename_column("label", "labels")
tokenized_datasets.set_format("torch")
tokenized_datasets["train"].column_names
```

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ç»“æœåªæœ‰æˆ‘ä»¬çš„æ¨¡å‹å°†æ¥å—çš„åˆ—ï¼š

```python
['attention_mask', 'input_ids', 'labels', 'token_type_ids']
```

ç°åœ¨è¿™æ˜¯å®Œæˆçš„ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾å®šä¹‰æˆ‘ä»¬çš„DataLoaderï¼š

```python
from torch.utils.data import DataLoader

train_dataloader = DataLoader(
    tokenized_datasets["train"], shuffle=True, batch_size=8, collate_fn=data_collator
)
eval_dataloader = DataLoader(
    tokenized_datasets["validation"], batch_size=8, collate_fn=data_collator
)
```

ä¸ºäº†å¿«é€Ÿæ£€æŸ¥æ•°æ®å¤„ç†ä¸­æ²¡æœ‰é”™è¯¯ï¼Œæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·æ£€æŸ¥ä¸€ä¸ªæ‰¹æ¬¡ï¼š

```python
for batch in train_dataloader:
    break
{k: v.shape for k, v in batch.items()}
{'attention_mask': torch.Size([8, 65]),
 'input_ids': torch.Size([8, 65]),
 'labels': torch.Size([8]),
 'token_type_ids': torch.Size([8, 65])}
```

è¯·æ³¨æ„ï¼Œå®é™…å½¢çŠ¶å¯èƒ½ä¸æ‚¨ç•¥æœ‰ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ºè®­ç»ƒæ•°æ®åŠ è½½å™¨è®¾ç½®äº† shuffle=True å¹¶ä¸”æˆ‘ä»¬æ­£åœ¨å¡«å……æ‰¹æ¬¡å†…çš„æœ€å¤§é•¿åº¦ã€‚ 

ç°åœ¨æˆ‘ä»¬å·²ç»å®Œå…¨å®Œæˆäº†æ•°æ®é¢„å¤„ç†ï¼ˆå¯¹äºä»»ä½• ML ä»ä¸šè€…æ¥è¯´éƒ½æ˜¯ä¸€ä¸ªä»¤äººæ»¡æ„ä½†éš¾ä»¥å®ç°çš„ç›®æ ‡ï¼‰ï¼Œè®©æˆ‘ä»¬è½¬å‘æ¨¡å‹ã€‚ æˆ‘ä»¬å®Œå…¨åƒåœ¨ä¸Šä¸€èŠ‚ä¸­æ‰€åšçš„é‚£æ ·å®ä¾‹åŒ–å®ƒï¼š 

```python
from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
```

è¦ç¡®ä¿åœ¨è®­ç»ƒæœŸé—´ä¸€åˆ‡é¡ºåˆ©ï¼Œæˆ‘ä»¬å°†æ‰¹æ¬¡ä¼ é€’ç»™æ­¤æ¨¡å‹ï¼š

```python
outputs = model(**batch)
print(outputs.loss, outputs.logits.shape)
tensor(0.5441, grad_fn=<NllLossBackward>) torch.Size([8, 2])
```

å½“æä¾›æ ‡ç­¾æ—¶ï¼Œæ‰€æœ‰ ğŸ¤— Transformers æ¨¡å‹éƒ½ä¼šè¿”å›æŸå¤±ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¾—åˆ° logitsï¼ˆæˆ‘ä»¬æ‰¹æ¬¡ä¸­çš„æ¯ä¸ªè¾“å…¥ä¸¤ä¸ªï¼Œæ‰€ä»¥å¼ é‡å¤§å°ä¸º 8 x 2ï¼‰ã€‚ æˆ‘ä»¬å‡ ä¹å‡†å¤‡å¥½ç¼–å†™æˆ‘ä»¬çš„è®­ç»ƒå¾ªç¯äº†ï¼ æˆ‘ä»¬åªæ˜¯ç¼ºå°‘ä¸¤ä»¶äº‹ï¼šä¼˜åŒ–å™¨å’Œå­¦ä¹ ç‡è°ƒåº¦å™¨ã€‚ ç”±äºæˆ‘ä»¬æ­£åœ¨å°è¯•æ‰‹åŠ¨å¤åˆ¶ Trainer æ‰€åšçš„äº‹æƒ…ï¼Œå› æ­¤æˆ‘ä»¬å°†ä½¿ç”¨ç›¸åŒçš„é»˜è®¤å€¼ã€‚ Trainer ä½¿ç”¨çš„ä¼˜åŒ–å™¨æ˜¯ AdamWï¼Œå®ƒä¸ Adam ç›¸åŒï¼Œä½†å¯¹æƒé‡è¡°å‡æ­£åˆ™åŒ–æœ‰æ‰€ä¸åŒï¼ˆå‚è§ Ilya Loshchilov å’Œ Frank Hutter çš„â€œè§£è€¦æƒé‡è¡°å‡æ­£åˆ™åŒ–â€[â€œDecoupled Weight Decay Regularizationâ€](https://arxiv.org/abs/1711.05101)ï¼‰ï¼š 

```python
from transformers import AdamW

optimizer = AdamW(model.parameters(), lr=5e-5)
```

æœ€åï¼Œé»˜è®¤ä½¿ç”¨çš„å­¦ä¹ ç‡è°ƒåº¦å™¨åªæ˜¯ä»æœ€å¤§å€¼ (5e-5) åˆ° 0 çš„çº¿æ€§è¡°å‡ã€‚ ä¸ºäº†æ­£ç¡®å®šä¹‰å®ƒï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æˆ‘ä»¬å°†é‡‡å–çš„è®­ç»ƒæ­¥éª¤æ•°ï¼Œå³ epochs æ•° æˆ‘ä»¬å¸Œæœ›è¿è¡Œä¹˜ä»¥è®­ç»ƒæ‰¹æ¬¡çš„æ•°é‡ï¼ˆè¿™æ˜¯æˆ‘ä»¬è®­ç»ƒæ•°æ®åŠ è½½å™¨çš„é•¿åº¦ï¼‰ã€‚ Trainer é»˜è®¤ä½¿ç”¨ä¸‰ä¸ª epochï¼Œæ‰€ä»¥æˆ‘ä»¬å°†éµå¾ªï¼š 

```python
from transformers import get_scheduler

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps
)
print(num_training_steps)
1377
```

# è®­ç»ƒå¾ªç¯

æœ€åä¸€ä»¶äº‹ï¼šå¦‚æœæˆ‘ä»¬å¯ä»¥è®¿é—® GPUï¼Œæˆ‘ä»¬å°†å¸Œæœ›ä½¿ç”¨ GPUï¼ˆåœ¨ CPU ä¸Šï¼Œè®­ç»ƒå¯èƒ½éœ€è¦å‡ ä¸ªå°æ—¶è€Œä¸æ˜¯å‡ åˆ†é’Ÿï¼‰ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªè®¾å¤‡ï¼Œæˆ‘ä»¬å°†æŠŠæˆ‘ä»¬çš„æ¨¡å‹å’Œæ‰¹æ¬¡æ”¾åœ¨ä¸Šé¢ï¼š

```python
import torch

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
model.to(device)
device
device(type='cuda')
```

æˆ‘ä»¬ç°åœ¨å‡†å¤‡å¥½è®­ç»ƒäº†ï¼ ä¸ºäº†äº†è§£è®­ç»ƒä½•æ—¶ç»“æŸï¼Œæˆ‘ä»¬ä½¿ç”¨ tqdm åº“åœ¨è®­ç»ƒæ­¥éª¤æ•°ä¸Šæ·»åŠ äº†ä¸€ä¸ªè¿›åº¦æ¡ï¼š 

```python
from tqdm.auto import tqdm

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        batch = {k: v.to(device) for k, v in batch.items()}
        outputs = model(**batch)
        loss = outputs.loss
        loss.backward()
        
        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

æ‚¨å¯ä»¥çœ‹åˆ°è®­ç»ƒå¾ªç¯çš„æ ¸å¿ƒä¸ä»‹ç»ä¸­çš„æ ¸å¿ƒéå¸¸ç›¸ä¼¼ã€‚ æˆ‘ä»¬æ²¡æœ‰è¦æ±‚ä»»ä½•æŠ¥å‘Šï¼Œæ‰€ä»¥è¿™ä¸ªè®­ç»ƒå¾ªç¯ä¸ä¼šå‘Šè¯‰æˆ‘ä»¬ä»»ä½•å…³äºæ¨¡å‹å¦‚ä½•è¿ä½œçš„ä¿¡æ¯ã€‚ æˆ‘ä»¬éœ€è¦ä¸ºæ­¤æ·»åŠ ä¸€ä¸ªè¯„ä¼°å¾ªç¯ã€‚ 

# è¯„ä¼°å¾ªç¯

æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ğŸ¤— Datasets åº“æä¾›çš„æŒ‡æ ‡ã€‚ æˆ‘ä»¬å·²ç»çœ‹åˆ°äº† metric.compute æ–¹æ³•ï¼Œä½†æ˜¯å½“æˆ‘ä»¬ä½¿ç”¨ add_batch æ–¹æ³•éå†é¢„æµ‹å¾ªç¯æ—¶ï¼Œmetrics å®é™…ä¸Šå¯ä»¥ä¸ºæˆ‘ä»¬ç´¯ç§¯æ‰¹æ¬¡ã€‚ ä¸€æ—¦æˆ‘ä»¬ç´¯ç§¯äº†æ‰€æœ‰æ‰¹æ¬¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ metric.compute() è·å¾—æœ€ç»ˆç»“æœã€‚ ä»¥ä¸‹æ˜¯åœ¨è¯„ä¼°å¾ªç¯ä¸­å®ç°æ‰€æœ‰è¿™äº›çš„æ–¹æ³•ï¼š 

```python
from datasets import load_metric

metric= load_metric("glue", "mrpc")
model.eval()
for batch in eval_dataloader:
    batch = {k: v.to(device) for k, v in batch.items()}
    with torch.no_grad():
        outputs = model(**batch)
    
    logits = outputs.logits
    predictions = torch.argmax(logits, dim=-1)
    metric.add_batch(predictions=predictions, references=batch["labels"])

metric.compute()
{'accuracy': 0.8431372549019608, 'f1': 0.8907849829351535}
```

åŒæ ·ï¼Œç”±äºæ¨¡å‹å¤´éƒ¨åˆå§‹åŒ–å’Œæ•°æ®æ··æ´—çš„éšæœºæ€§ï¼Œæ‚¨çš„ç»“æœä¼šç•¥æœ‰ä¸åŒï¼Œä½†å®ƒä»¬åº”è¯¥åœ¨åŒä¸€ä¸ªèŒƒå›´å†…ã€‚ 

# ä½¿ç”¨ ğŸ¤— Accelerate å¢å¼ºæ‚¨çš„è®­ç»ƒå¾ªç¯ 

æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„è®­ç»ƒå¾ªç¯åœ¨å•ä¸ª CPU æˆ– GPU ä¸Šè¿è¡Œè‰¯å¥½ã€‚ ä½†æ˜¯ä½¿ç”¨ ğŸ¤— [Accelerate](https://github.com/huggingface/accelerate) åº“ï¼Œåªéœ€è¿›è¡Œä¸€äº›è°ƒæ•´ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨å¤šä¸ª GPU æˆ– TPU ä¸Šå¯ç”¨åˆ†å¸ƒå¼è®­ç»ƒã€‚ ä»åˆ›å»ºè®­ç»ƒå’ŒéªŒè¯æ•°æ®åŠ è½½å™¨å¼€å§‹ï¼Œæˆ‘ä»¬çš„æ‰‹åŠ¨è®­ç»ƒå¾ªç¯å¦‚ä¸‹æ‰€ç¤ºï¼š 

```python
from transformers import AdamW, AutoModelForSequenceClassification, get_scheduler

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
optimizer = AdamW(model.parameters(), lr=3e-5)

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
model.to(device)

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps
)

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        batch = {k: v.to(device) for k, v in batch.items()}
        outputs = model(**batch)
        loss = outputs.loss
        loss.backward()
        
        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

ä»¥ä¸‹æ˜¯å˜åŒ–ï¼š 

```python
+ from accelerate import Accelerator
  from transformers import AdamW, AutoModelForSequenceClassification, get_scheduler

+ accelerator = Accelerator()

  model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
  optimizer = AdamW(model.parameters(), lr=3e-5)

- device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
- model.to(device)

+ train_dataloader, eval_dataloader, model, optimizer = accelerator.prepare(
+     train_dataloader, eval_dataloader, model, optimizer
+ )

  num_epochs = 3
  num_training_steps = num_epochs * len(train_dataloader)
  lr_scheduler = get_scheduler(
      "linear",
      optimizer=optimizer,
      num_warmup_steps=0,
      num_training_steps=num_training_steps
  )

  progress_bar = tqdm(range(num_training_steps))

  model.train()
  for epoch in range(num_epochs):
      for batch in train_dataloader:
-         batch = {k: v.to(device) for k, v in batch.items()}
          outputs = model(**batch)
          loss = outputs.loss
-         loss.backward()
+         accelerator.backward(loss)

          optimizer.step()
          lr_scheduler.step()
          optimizer.zero_grad()
          progress_bar.update(1)
```

è¦æ·»åŠ çš„ç¬¬ä¸€è¡Œæ˜¯å¯¼å…¥è¡Œã€‚ ç¬¬äºŒè¡Œå®ä¾‹åŒ–ä¸€ä¸ª Accelerator å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å°†æŸ¥çœ‹ç¯å¢ƒå¹¶åˆå§‹åŒ–æ­£ç¡®çš„åˆ†å¸ƒå¼è®¾ç½®ã€‚ ğŸ¤— Accelerate ä¸ºæ‚¨å¤„ç†è®¾å¤‡æ”¾ç½®ï¼Œå› æ­¤æ‚¨å¯ä»¥åˆ é™¤å°†æ¨¡å‹æ”¾ç½®åœ¨è®¾å¤‡ä¸Šçš„çº¿æ¡ï¼ˆæˆ–è€…ï¼Œå¦‚æœæ‚¨æ„¿æ„ï¼Œå¯ä»¥å°†å®ƒä»¬æ›´æ”¹ä¸ºä½¿ç”¨ Accelerate.device è€Œä¸æ˜¯ deviceï¼‰ã€‚ 

ç„¶åå¤§éƒ¨åˆ†å·¥ä½œåœ¨å°†æ•°æ®åŠ è½½å™¨ã€æ¨¡å‹å’Œä¼˜åŒ–å™¨å‘é€åˆ°åŠ é€Ÿå™¨.prepare çš„è¡Œä¸­å®Œæˆã€‚ è¿™ä¼šå°†è¿™äº›å¯¹è±¡åŒ…è£…åœ¨é€‚å½“çš„å®¹å™¨ä¸­ï¼Œä»¥ç¡®ä¿æ‚¨çš„åˆ†å¸ƒå¼è®­ç»ƒæŒ‰é¢„æœŸå·¥ä½œã€‚ è¦è¿›è¡Œçš„å…¶ä½™æ›´æ”¹æ˜¯åˆ é™¤å°†æ‰¹å¤„ç†æ”¾åœ¨è®¾å¤‡ä¸Šçš„è¡Œï¼ˆåŒæ ·ï¼Œå¦‚æœæ‚¨æƒ³ä¿ç•™å®ƒï¼Œæ‚¨å¯ä»¥å°†å…¶æ›´æ”¹ä¸ºä½¿ç”¨accelerator.deviceï¼‰å¹¶å°†loss.backward() æ›¿æ¢ä¸ºaccelerator.backward(loss) ã€‚

å¦‚æœæ‚¨æƒ³å¤åˆ¶å¹¶ç²˜è´´å®ƒä»¥è¿›è¡Œå®éªŒï¼Œä»¥ä¸‹æ˜¯ ğŸ¤— Accelerate çš„å®Œæ•´è®­ç»ƒå¾ªç¯ï¼š 

```python
from accelerate import Accelerator
from transformers import AdamW, AutoModelForSequenceClassification, get_scheduler

accelerator = Accelerator()

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
optimizer = AdamW(model.parameters(), lr=3e-5)

train_dataloader, eval_dataloader, model, optimizer = accelerator.prepare(
    train_dataloader, eval_dataloader, model, optimizer
)

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps
)

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)
        
        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

å°†å®ƒæ”¾åœ¨ train.py è„šæœ¬ä¸­å°†ä½¿è¯¥è„šæœ¬å¯åœ¨ä»»ä½•ç±»å‹çš„åˆ†å¸ƒå¼è®¾ç½®ä¸Šè¿è¡Œã€‚ è¦åœ¨åˆ†å¸ƒå¼è®¾ç½®ä¸­è¯•ç”¨å®ƒï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 

```python
accelerate config
```

è¿™å°†æç¤ºæ‚¨å›ç­”å‡ ä¸ªé—®é¢˜å¹¶å°†æ‚¨çš„ç­”æ¡ˆè½¬å‚¨åˆ°æ­¤å‘½ä»¤ä½¿ç”¨çš„é…ç½®æ–‡ä»¶ä¸­ï¼š 

```python
accelerate launch train.py
```

è¿™å°†å¯åŠ¨åˆ†å¸ƒå¼è®­ç»ƒã€‚ å¦‚æœæ‚¨æƒ³åœ¨ Notebook ä¸­å°è¯•æ­¤æ“ä½œï¼ˆä¾‹å¦‚ï¼Œåœ¨ Colab ä¸Šä½¿ç”¨ TPU å¯¹å…¶è¿›è¡Œæµ‹è¯•ï¼‰ï¼Œåªéœ€å°†ä»£ç ç²˜è´´åˆ° training_function ä¸­å¹¶ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œæœ€åä¸€ä¸ªå•å…ƒæ ¼ï¼š 

```python
from accelerate import notebook_launcher

notebook_launcher(training_function)
```

æ‚¨å¯ä»¥åœ¨ ğŸ¤— [Accelerate repo](https://github.com/huggingface/accelerate/tree/main/examples).ä¸­æ‰¾åˆ°æ›´å¤šç¤ºä¾‹ã€‚ 